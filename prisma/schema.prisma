generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Mantenha o provider que você está usando (sqlite ou postgresql)
  url      = env("DATABASE_URL")
}

// --------------------------------------------------------
// ENUMS
// --------------------------------------------------------

enum UserRole {
  OWNER
  DOCTOR
  SECRETARY
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum TransactionType {
  INCOME
  EXPENSE
}

enum NotificationType {
  WHATSAPP
  EMAIL
  SMS
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
}

// Novos Enums Financeiros
enum ExpenseCategory {
  RENT
  SALARY
  SUPPLIES
  TAXES
  MARKETING
  OTHER
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
}

// --------------------------------------------------------
// MODELS
// --------------------------------------------------------

model Tenant {
  id            String   @id @default(cuid())
  name          String
  slug          String   @unique
  plan          String   @default("FREE")

  address       String?
  logoUrl       String?
  primaryColor  String?  @default("#000000")
  whatsappPhone String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  users         User[]
  patients      Patient[]
  appointments  Appointment[]
  expenses      Expense[]        // Nova relação
  finance       FinancialRecord[] // Mantido legado se necessário
  services      Service[]
  notifications NotificationLog[]
}

model User {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  password      String
  phone         String?
  role          UserRole @default(DOCTOR)
  
  crm           String?
  specialty     String?
  
  tenantId      String
  tenant        Tenant   @relation(fields: [tenantId], references: [id])

  appointments  Appointment[]
  availabilities Availability[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Patient {
  id            String    @id @default(cuid())
  name          String
  email         String?
  phone         String
  cpf           String?
  birthDate     DateTime?
  address       String?
  
  tenantId      String
  tenant        Tenant    @relation(fields: [tenantId], references: [id])

  appointments  Appointment[]
  records       MedicalRecord[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([cpf, tenantId])
}

model MedicalRecord {
  id            String   @id @default(cuid())
  description   String   @db.Text
  prescription  String?  @db.Text
  anamnesisData Json?

  patientId     String
  patient       Patient  @relation(fields: [patientId], references: [id])
  
  doctorId      String
  // doctor User @relation(...) // Adicione se necessário conectar ao médico
  
  attachments   Attachment[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Attachment {
  id              String        @id @default(cuid())
  name            String
  url             String
  type            String
  
  medicalRecordId String
  medicalRecord   MedicalRecord @relation(fields: [medicalRecordId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime      @default(now())
}

model Service {
  id          String   @id @default(cuid())
  name        String
  durationMin Int
  price       Decimal  @db.Decimal(10, 2)
  
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  
  appointments Appointment[]
  
  active      Boolean  @default(true)
}

model Appointment {
  id            String            @id @default(cuid())
  date          DateTime
  status        AppointmentStatus @default(PENDING)
  notes         String?
  price         Decimal           @default(0.00) @db.Decimal(10, 2)
  
  // Novos campos financeiros
  paymentStatus PaymentStatus     @default(PENDING)
  paymentMethod String?
  transactionId String?

  tenantId      String
  tenant        Tenant    @relation(fields: [tenantId], references: [id])
  
  patientId     String
  patient       Patient   @relation(fields: [patientId], references: [id])
  
  doctorId      String
  doctor        User      @relation(fields: [doctorId], references: [id])
  
  serviceId     String?
  service       Service?  @relation(fields: [serviceId], references: [id])

  notifications NotificationLog[]

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Availability {
  id        String   @id @default(cuid())
  dayOfWeek Int
  startTime String
  endTime   String
  
  userId    String
  user      User     @relation(fields: [userId], references: [id])
}

// Model Novo Exclusivo para Despesas
model Expense {
  id          String          @id @default(cuid())
  description String
  amount      Decimal         @db.Decimal(10, 2)
  date        DateTime
  category    ExpenseCategory
  
  tenantId    String
  tenant      Tenant          @relation(fields: [tenantId], references: [id])

  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([tenantId])
}

// Mantido para compatibilidade, mas o foco agora é Appointment(Receita) + Expense(Despesa)
model FinancialRecord {
  id          String          @id @default(cuid())
  description String
  amount      Decimal         @db.Decimal(10, 2)
  type        TransactionType
  category    String
  date        DateTime        @default(now())
  status      String          @default("PAID")
  
  tenantId    String
  tenant      Tenant          @relation(fields: [tenantId], references: [id])
  
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
}

model NotificationLog {
  id            String       @id @default(cuid())
  type          String       @default("WHATSAPP")
  status        String       @default("PENDING")
  recipient     String
  content       String
  externalId    String?

  appointmentId String?
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  
  tenantId      String
  tenant        Tenant       @relation(fields: [tenantId], references: [id])
  
  createdAt     DateTime     @default(now())
}